/**
 * (C) Copyright IBM Corp. 2020.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package casemanagementv1 : Operations and models for the CaseManagementV1 service
package casemanagementv1

import (
	"fmt"
	"github.com/IBM/go-sdk-core/v3/core"
	common "github.ibm.com/ibmcloud/platform-services-go-sdk/common"
	"io"
	"strings"
)

// CaseManagementV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// Version: 1.0
type CaseManagementV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://support-center.cloud.ibm.com/"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "case_management"

// CaseManagementV1Options : Service options
type CaseManagementV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewCaseManagementV1UsingExternalConfig : constructs an instance of CaseManagementV1 with passed in options and external configuration.
func NewCaseManagementV1UsingExternalConfig(options *CaseManagementV1Options) (caseManagement *CaseManagementV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	caseManagement, err = NewCaseManagementV1(options)
	if err != nil {
		return
	}

	err = caseManagement.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = caseManagement.Service.SetServiceURL(options.URL)
	}
	return
}

// NewCaseManagementV1 : constructs an instance of CaseManagementV1 with passed in options.
func NewCaseManagementV1(options *CaseManagementV1Options) (service *CaseManagementV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &CaseManagementV1{
		Service: baseService,
	}

	return
}

// SetServiceURL sets the service URL
func (caseManagement *CaseManagementV1) SetServiceURL(url string) error {
	return caseManagement.Service.SetServiceURL(url)
}

// GetCases : Get cases in account
// Get cases in the account which is specified by the content of the IAM token.
func (caseManagement *CaseManagementV1) GetCases(getCasesOptions *GetCasesOptions) (result *CaseCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getCasesOptions, "getCasesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getCasesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "GetCases")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getCasesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*getCasesOptions.Offset))
	}
	if getCasesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*getCasesOptions.Limit))
	}
	if getCasesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*getCasesOptions.Search))
	}
	if getCasesOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*getCasesOptions.Sort))
	}
	if getCasesOptions.Status != nil {
		builder.AddQuery("status", strings.Join(getCasesOptions.Status, ","))
	}
	if getCasesOptions.Fields != nil {
		builder.AddQuery("fields", strings.Join(getCasesOptions.Fields, ","))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCaseCollection(m)
		response.Result = result
	}

	return
}

// CreateCase : Create a case
// Create a case in the account.
func (caseManagement *CaseManagementV1) CreateCase(createCaseOptions *CreateCaseOptions) (result *Case, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(createCaseOptions, "createCaseOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createCaseOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "CreateCase")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createCaseOptions.Type != nil {
		body["type"] = createCaseOptions.Type
	}
	if createCaseOptions.Subject != nil {
		body["subject"] = createCaseOptions.Subject
	}
	if createCaseOptions.Description != nil {
		body["description"] = createCaseOptions.Description
	}
	if createCaseOptions.Severity != nil {
		body["severity"] = createCaseOptions.Severity
	}
	if createCaseOptions.Eu != nil {
		body["eu"] = createCaseOptions.Eu
	}
	if createCaseOptions.Offering != nil {
		body["offering"] = createCaseOptions.Offering
	}
	if createCaseOptions.Resources != nil {
		body["resources"] = createCaseOptions.Resources
	}
	if createCaseOptions.Watchlist != nil {
		body["watchlist"] = createCaseOptions.Watchlist
	}
	if createCaseOptions.InvoiceNumber != nil {
		body["invoice_number"] = createCaseOptions.InvoiceNumber
	}
	if createCaseOptions.SlaCreditRequest != nil {
		body["sla_credit_request"] = createCaseOptions.SlaCreditRequest
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCase(m)
		response.Result = result
	}

	return
}

// GetCase : Get a case in account
// Get a case in the account that is specified by the case number.
func (caseManagement *CaseManagementV1) GetCase(getCaseOptions *GetCaseOptions) (result *Case, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getCaseOptions, "getCaseOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getCaseOptions, "getCaseOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases"}
	pathParameters := []string{*getCaseOptions.CaseNumber}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getCaseOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "GetCase")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getCaseOptions.Fields != nil {
		builder.AddQuery("fields", strings.Join(getCaseOptions.Fields, ","))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCase(m)
		response.Result = result
	}

	return
}

// UpdateCaseStatus : Update case status
// Mark the case as resolved or unresolved, or accept the provided resolution.
func (caseManagement *CaseManagementV1) UpdateCaseStatus(updateCaseStatusOptions *UpdateCaseStatusOptions) (result *Case, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateCaseStatusOptions, "updateCaseStatusOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateCaseStatusOptions, "updateCaseStatusOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "status"}
	pathParameters := []string{*updateCaseStatusOptions.CaseNumber}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateCaseStatusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "UpdateCaseStatus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateCaseStatusOptions.Action != nil {
		body["action"] = updateCaseStatusOptions.Action
	}
	if updateCaseStatusOptions.Comment != nil {
		body["comment"] = updateCaseStatusOptions.Comment
	}
	if updateCaseStatusOptions.ResolutionCode != nil {
		body["resolution_code"] = updateCaseStatusOptions.ResolutionCode
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalCase(m)
		response.Result = result
	}

	return
}

// AddComment : Add comment to case
// Add a comment to a case.
func (caseManagement *CaseManagementV1) AddComment(addCommentOptions *AddCommentOptions) (result *Comment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addCommentOptions, "addCommentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addCommentOptions, "addCommentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "comments"}
	pathParameters := []string{*addCommentOptions.CaseNumber}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addCommentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "AddComment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if addCommentOptions.Comment != nil {
		body["comment"] = addCommentOptions.Comment
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalComment(m)
		response.Result = result
	}

	return
}

// AddWatchlist : Add users to watchlist of case
// Add users to the watchlist of case. By adding a user to the watchlist of the case, you are granting them read and
// write permissions, so the user can view the case, receive updates, and make updates to the case. Note that the user
// must be in the account to be added to the watchlist.
func (caseManagement *CaseManagementV1) AddWatchlist(addWatchlistOptions *AddWatchlistOptions) (result *AddWatchlistResults, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addWatchlistOptions, "addWatchlistOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addWatchlistOptions, "addWatchlistOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "watchlist"}
	pathParameters := []string{*addWatchlistOptions.CaseNumber}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addWatchlistOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "AddWatchlist")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if addWatchlistOptions.Watchlist != nil {
		body["watchlist"] = addWatchlistOptions.Watchlist
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalAddWatchlistResults(m)
		response.Result = result
	}

	return
}

// RemoveWatchlist : Remove users from watchlist of case
// Remove users from the watchlist of a case.
func (caseManagement *CaseManagementV1) RemoveWatchlist(removeWatchlistOptions *RemoveWatchlistOptions) (result *[]User, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeWatchlistOptions, "removeWatchlistOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeWatchlistOptions, "removeWatchlistOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "watchlist"}
	pathParameters := []string{*removeWatchlistOptions.CaseNumber}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeWatchlistOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "RemoveWatchlist")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if removeWatchlistOptions.Watchlist != nil {
		body["watchlist"] = removeWatchlistOptions.Watchlist
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make([]map[string]interface{}, 1))
	if err == nil {
		s, ok := response.Result.([]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		slice, e := UnmarshalUserSlice(s)
		result = &slice
		err = e
		response.Result = result
	}

	return
}

// AddResource : Add a resource to case
// Add a resource to case by specifying the Cloud Resource Name (CRN), or id and type if attaching a class iaaS
// resource.
func (caseManagement *CaseManagementV1) AddResource(addResourceOptions *AddResourceOptions) (result *Resource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addResourceOptions, "addResourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addResourceOptions, "addResourceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "resources"}
	pathParameters := []string{*addResourceOptions.CaseNumber}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addResourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "AddResource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if addResourceOptions.Crn != nil {
		body["crn"] = addResourceOptions.Crn
	}
	if addResourceOptions.Name != nil {
		body["name"] = addResourceOptions.Name
	}
	if addResourceOptions.Type != nil {
		body["type"] = addResourceOptions.Type
	}
	if addResourceOptions.ID != nil {
		body["id"] = addResourceOptions.ID
	}
	if addResourceOptions.Note != nil {
		body["note"] = addResourceOptions.Note
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalResource(m)
		response.Result = result
	}

	return
}

// UploadFile : Add attachment(s) to case
// You can add attachments to a case to provide more information for the support team about the issue that you're
// experiencing.
func (caseManagement *CaseManagementV1) UploadFile(uploadFileOptions *UploadFileOptions) (result *Attachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(uploadFileOptions, "uploadFileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(uploadFileOptions, "uploadFileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "attachments"}
	pathParameters := []string{*uploadFileOptions.CaseNumber}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range uploadFileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "UploadFile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddFormData("file", "filename",
		core.StringNilMapper(uploadFileOptions.FileContentType), uploadFileOptions.File)

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalAttachment(m)
		response.Result = result
	}

	return
}

// DownloadFile : Download an attachment
// Download an attachment from a case.
func (caseManagement *CaseManagementV1) DownloadFile(downloadFileOptions *DownloadFileOptions) (result io.ReadCloser, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(downloadFileOptions, "downloadFileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(downloadFileOptions, "downloadFileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "attachments"}
	pathParameters := []string{*downloadFileOptions.CaseNumber, *downloadFileOptions.FileID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range downloadFileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "DownloadFile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/octet-stream")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, new(io.ReadCloser))
	if err == nil {
		var ok bool
		result, ok = response.Result.(io.ReadCloser)
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
		}
	}

	return
}

// DeleteFile : Remove attachment from case
// Remove an attachment from a case.
func (caseManagement *CaseManagementV1) DeleteFile(deleteFileOptions *DeleteFileOptions) (result *DeleteFileResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFileOptions, "deleteFileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteFileOptions, "deleteFileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/v1/cases", "attachments"}
	pathParameters := []string{*deleteFileOptions.CaseNumber, *deleteFileOptions.FileID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteFileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "DeleteFile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalDeleteFileResponse(m)
		response.Result = result
	}

	return
}

// GetEUSupport : Shows how to mark case as EU supported
// Shows how an account can mark a case as EU supported.
func (caseManagement *CaseManagementV1) GetEUSupport(getEUSupportOptions *GetEUSupportOptions) (result *EuSupport, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getEUSupportOptions, "getEUSupportOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/utilities/v1/eu-support"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getEUSupportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "GetEUSupport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalEuSupport(m)
		response.Result = result
	}

	return
}

// GetTechnicalOfferings : Get offerings
// Get offerings used in technical cases.
func (caseManagement *CaseManagementV1) GetTechnicalOfferings(getTechnicalOfferingsOptions *GetTechnicalOfferingsOptions) (result *TechnicalOfferingsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getTechnicalOfferingsOptions, "getTechnicalOfferingsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/utilities/v1/offerings/technical"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTechnicalOfferingsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "GetTechnicalOfferings")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalTechnicalOfferingsResponse(m)
		response.Result = result
	}

	return
}

// GetResolutionCodes : Get resolution code values
// Get the resolution code values used in "Update Status API".
func (caseManagement *CaseManagementV1) GetResolutionCodes(getResolutionCodesOptions *GetResolutionCodesOptions) (result *ResolutionCodesResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getResolutionCodesOptions, "getResolutionCodesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/utilities/v1/constants/resolution-codes"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getResolutionCodesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "GetResolutionCodes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalResolutionCodesResponse(m)
		response.Result = result
	}

	return
}

// GetStatuses : Get status values
// Get the status values used in case filtering.
func (caseManagement *CaseManagementV1) GetStatuses(getStatusesOptions *GetStatusesOptions) (result *StatusesResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getStatusesOptions, "getStatusesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"case-management/utilities/v1/constants/statuses"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(caseManagement.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStatusesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("case_management", "V1", "GetStatuses")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = caseManagement.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalStatusesResponse(m)
		response.Result = result
	}

	return
}

// AddCommentOptions : The AddComment options.
type AddCommentOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// the comment to be added to the case.
	Comment *string `json:"comment" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddCommentOptions : Instantiate AddCommentOptions
func (*CaseManagementV1) NewAddCommentOptions(caseNumber string, comment string) *AddCommentOptions {
	return &AddCommentOptions{
		CaseNumber: core.StringPtr(caseNumber),
		Comment: core.StringPtr(comment),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *AddCommentOptions) SetCaseNumber(caseNumber string) *AddCommentOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetComment : Allow user to set Comment
func (options *AddCommentOptions) SetComment(comment string) *AddCommentOptions {
	options.Comment = core.StringPtr(comment)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddCommentOptions) SetHeaders(param map[string]string) *AddCommentOptions {
	options.Headers = param
	return options
}

// AddResourceOptions : The AddResource options.
type AddResourceOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// Cloud Resource Name of the resource.
	Crn *string `json:"crn,omitempty"`

	// Name of the resource.
	Name *string `json:"name,omitempty"`

	// Only used to attach Classic IaaS devices which have no CRN.
	Type *string `json:"type,omitempty"`

	// Only used to attach Classic IaaS devices which have no CRN. Id of Classic IaaS device.
	ID *int64 `json:"id,omitempty"`

	// A note about this resource.
	Note *string `json:"note,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddResourceOptions : Instantiate AddResourceOptions
func (*CaseManagementV1) NewAddResourceOptions(caseNumber string) *AddResourceOptions {
	return &AddResourceOptions{
		CaseNumber: core.StringPtr(caseNumber),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *AddResourceOptions) SetCaseNumber(caseNumber string) *AddResourceOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetCrn : Allow user to set Crn
func (options *AddResourceOptions) SetCrn(crn string) *AddResourceOptions {
	options.Crn = core.StringPtr(crn)
	return options
}

// SetName : Allow user to set Name
func (options *AddResourceOptions) SetName(name string) *AddResourceOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetType : Allow user to set Type
func (options *AddResourceOptions) SetType(typeVar string) *AddResourceOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetID : Allow user to set ID
func (options *AddResourceOptions) SetID(id int64) *AddResourceOptions {
	options.ID = core.Int64Ptr(id)
	return options
}

// SetNote : Allow user to set Note
func (options *AddResourceOptions) SetNote(note string) *AddResourceOptions {
	options.Note = core.StringPtr(note)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddResourceOptions) SetHeaders(param map[string]string) *AddResourceOptions {
	options.Headers = param
	return options
}

// AddWatchlistOptions : The AddWatchlist options.
type AddWatchlistOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// List of users to be added or removed from the watchlist of a case.
	Watchlist []UserIdAndRealm `json:"watchlist,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddWatchlistOptions : Instantiate AddWatchlistOptions
func (*CaseManagementV1) NewAddWatchlistOptions(caseNumber string) *AddWatchlistOptions {
	return &AddWatchlistOptions{
		CaseNumber: core.StringPtr(caseNumber),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *AddWatchlistOptions) SetCaseNumber(caseNumber string) *AddWatchlistOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetWatchlist : Allow user to set Watchlist
func (options *AddWatchlistOptions) SetWatchlist(watchlist []UserIdAndRealm) *AddWatchlistOptions {
	options.Watchlist = watchlist
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddWatchlistOptions) SetHeaders(param map[string]string) *AddWatchlistOptions {
	options.Headers = param
	return options
}

// CreateCaseOptions : The CreateCase options.
type CreateCaseOptions struct {
	// the case type.
	Type *string `json:"type,omitempty"`

	// Subject of the case.
	Subject *string `json:"subject,omitempty"`

	// Detailed description of the issue.
	Description *string `json:"description,omitempty"`

	// the severity associated with the case (1 - 4).
	Severity *int64 `json:"severity,omitempty"`

	// Specify if the case should be treated as EU regulated. Only one of the following properties is required. Call EU
	// support utility endpoint to determine which property must be specified for your account.
	Eu *EuPayload `json:"eu,omitempty"`

	// The offering of a case to be created.
	Offering *OfferingPayload `json:"offering,omitempty"`

	// List of resources to attach to case. If attaching Classic IaaS devices use type and id fields if Cloud Resource Name
	// (CRN) is unavialable. Otherwise pass the resource CRN. The resource list must be consistent with the value selected
	// for the resource offering.
	Resources []Resource `json:"resources,omitempty"`

	// User IDs in the watchlist.
	Watchlist []User `json:"watchlist,omitempty"`

	// Invoice number of "Billing and Invoice" case type.
	InvoiceNumber *string `json:"invoice_number,omitempty"`

	// Flag to indicate if case is for an Service Level Agreement (SLA) credit request.
	SlaCreditRequest *bool `json:"sla_credit_request,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateCaseOptions.Type property.
// the case type.
const (
	CreateCaseOptions_Type_AccountAndAccess = "account_and_access"
	CreateCaseOptions_Type_BillingAndInvoice = "billing_and_invoice"
	CreateCaseOptions_Type_Sales = "sales"
	CreateCaseOptions_Type_Technical = "technical"
)

// NewCreateCaseOptions : Instantiate CreateCaseOptions
func (*CaseManagementV1) NewCreateCaseOptions() *CreateCaseOptions {
	return &CreateCaseOptions{}
}

// SetType : Allow user to set Type
func (options *CreateCaseOptions) SetType(typeVar string) *CreateCaseOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetSubject : Allow user to set Subject
func (options *CreateCaseOptions) SetSubject(subject string) *CreateCaseOptions {
	options.Subject = core.StringPtr(subject)
	return options
}

// SetDescription : Allow user to set Description
func (options *CreateCaseOptions) SetDescription(description string) *CreateCaseOptions {
	options.Description = core.StringPtr(description)
	return options
}

// SetSeverity : Allow user to set Severity
func (options *CreateCaseOptions) SetSeverity(severity int64) *CreateCaseOptions {
	options.Severity = core.Int64Ptr(severity)
	return options
}

// SetEu : Allow user to set Eu
func (options *CreateCaseOptions) SetEu(eu *EuPayload) *CreateCaseOptions {
	options.Eu = eu
	return options
}

// SetOffering : Allow user to set Offering
func (options *CreateCaseOptions) SetOffering(offering *OfferingPayload) *CreateCaseOptions {
	options.Offering = offering
	return options
}

// SetResources : Allow user to set Resources
func (options *CreateCaseOptions) SetResources(resources []Resource) *CreateCaseOptions {
	options.Resources = resources
	return options
}

// SetWatchlist : Allow user to set Watchlist
func (options *CreateCaseOptions) SetWatchlist(watchlist []User) *CreateCaseOptions {
	options.Watchlist = watchlist
	return options
}

// SetInvoiceNumber : Allow user to set InvoiceNumber
func (options *CreateCaseOptions) SetInvoiceNumber(invoiceNumber string) *CreateCaseOptions {
	options.InvoiceNumber = core.StringPtr(invoiceNumber)
	return options
}

// SetSlaCreditRequest : Allow user to set SlaCreditRequest
func (options *CreateCaseOptions) SetSlaCreditRequest(slaCreditRequest bool) *CreateCaseOptions {
	options.SlaCreditRequest = core.BoolPtr(slaCreditRequest)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateCaseOptions) SetHeaders(param map[string]string) *CreateCaseOptions {
	options.Headers = param
	return options
}

// DeleteFileOptions : The DeleteFile options.
type DeleteFileOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// Unique identifier of a file.
	FileID *string `json:"file_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteFileOptions : Instantiate DeleteFileOptions
func (*CaseManagementV1) NewDeleteFileOptions(caseNumber string, fileID string) *DeleteFileOptions {
	return &DeleteFileOptions{
		CaseNumber: core.StringPtr(caseNumber),
		FileID: core.StringPtr(fileID),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *DeleteFileOptions) SetCaseNumber(caseNumber string) *DeleteFileOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetFileID : Allow user to set FileID
func (options *DeleteFileOptions) SetFileID(fileID string) *DeleteFileOptions {
	options.FileID = core.StringPtr(fileID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFileOptions) SetHeaders(param map[string]string) *DeleteFileOptions {
	options.Headers = param
	return options
}

// DownloadFileOptions : The DownloadFile options.
type DownloadFileOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// Unique identifier of a file.
	FileID *string `json:"file_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDownloadFileOptions : Instantiate DownloadFileOptions
func (*CaseManagementV1) NewDownloadFileOptions(caseNumber string, fileID string) *DownloadFileOptions {
	return &DownloadFileOptions{
		CaseNumber: core.StringPtr(caseNumber),
		FileID: core.StringPtr(fileID),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *DownloadFileOptions) SetCaseNumber(caseNumber string) *DownloadFileOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetFileID : Allow user to set FileID
func (options *DownloadFileOptions) SetFileID(fileID string) *DownloadFileOptions {
	options.FileID = core.StringPtr(fileID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DownloadFileOptions) SetHeaders(param map[string]string) *DownloadFileOptions {
	options.Headers = param
	return options
}

// GetCaseOptions : The GetCase options.
type GetCaseOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// Selected fields of interest instead of the entire case information.
	Fields []string `json:"fields,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetCaseOptions : Instantiate GetCaseOptions
func (*CaseManagementV1) NewGetCaseOptions(caseNumber string) *GetCaseOptions {
	return &GetCaseOptions{
		CaseNumber: core.StringPtr(caseNumber),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *GetCaseOptions) SetCaseNumber(caseNumber string) *GetCaseOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetFields : Allow user to set Fields
func (options *GetCaseOptions) SetFields(fields []string) *GetCaseOptions {
	options.Fields = fields
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetCaseOptions) SetHeaders(param map[string]string) *GetCaseOptions {
	options.Headers = param
	return options
}

// GetCasesOptions : The GetCases options.
type GetCasesOptions struct {
	// Number of cases should be skipped.
	Offset *int64 `json:"offset,omitempty"`

	// Number of cases should be returned.
	Limit *int64 `json:"limit,omitempty"`

	// String that a case might contain.
	Search *string `json:"search,omitempty"`

	// Sort field and direction. If omitted, default to descending of updated date. Prefix "~" signifies sort in
	// descending.
	Sort *string `json:"sort,omitempty"`

	// Case status filter.
	Status []string `json:"status,omitempty"`

	// Selected fields of interest instead of the entire case information.
	Fields []string `json:"fields,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetCasesOptions.Status property.
const (
	GetCasesOptions_Status_Closed = "closed"
	GetCasesOptions_Status_InProgress = "in_progress"
	GetCasesOptions_Status_New = "new"
	GetCasesOptions_Status_ResolutionProvided = "resolution_provided"
	GetCasesOptions_Status_Resolved = "resolved"
	GetCasesOptions_Status_WaitingOnClient = "waiting_on_client"
)

// Constants associated with the GetCasesOptions.Fields property.
const (
	GetCasesOptions_Fields_Attachments = "attachments"
	GetCasesOptions_Fields_CloseNotes = "close_notes"
	GetCasesOptions_Fields_Comments = "comments"
	GetCasesOptions_Fields_Contact = "contact"
	GetCasesOptions_Fields_ContactType = "contact_type"
	GetCasesOptions_Fields_CreatedAt = "created_at"
	GetCasesOptions_Fields_CreatedBy = "created_by"
	GetCasesOptions_Fields_Description = "description"
	GetCasesOptions_Fields_Eu = "eu"
	GetCasesOptions_Fields_InvoiceNumber = "invoice_number"
	GetCasesOptions_Fields_Number = "number"
	GetCasesOptions_Fields_Offering = "offering"
	GetCasesOptions_Fields_Resolution = "resolution"
	GetCasesOptions_Fields_Resources = "resources"
	GetCasesOptions_Fields_Severity = "severity"
	GetCasesOptions_Fields_ShortDescription = "short_description"
	GetCasesOptions_Fields_Status = "status"
	GetCasesOptions_Fields_SupportTier = "support_tier"
	GetCasesOptions_Fields_UpdatedAt = "updated_at"
	GetCasesOptions_Fields_UpdatedBy = "updated_by"
	GetCasesOptions_Fields_Watchlist = "watchlist"
)

// NewGetCasesOptions : Instantiate GetCasesOptions
func (*CaseManagementV1) NewGetCasesOptions() *GetCasesOptions {
	return &GetCasesOptions{}
}

// SetOffset : Allow user to set Offset
func (options *GetCasesOptions) SetOffset(offset int64) *GetCasesOptions {
	options.Offset = core.Int64Ptr(offset)
	return options
}

// SetLimit : Allow user to set Limit
func (options *GetCasesOptions) SetLimit(limit int64) *GetCasesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetSearch : Allow user to set Search
func (options *GetCasesOptions) SetSearch(search string) *GetCasesOptions {
	options.Search = core.StringPtr(search)
	return options
}

// SetSort : Allow user to set Sort
func (options *GetCasesOptions) SetSort(sort string) *GetCasesOptions {
	options.Sort = core.StringPtr(sort)
	return options
}

// SetStatus : Allow user to set Status
func (options *GetCasesOptions) SetStatus(status []string) *GetCasesOptions {
	options.Status = status
	return options
}

// SetFields : Allow user to set Fields
func (options *GetCasesOptions) SetFields(fields []string) *GetCasesOptions {
	options.Fields = fields
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetCasesOptions) SetHeaders(param map[string]string) *GetCasesOptions {
	options.Headers = param
	return options
}

// GetEUSupportOptions : The GetEUSupport options.
type GetEUSupportOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetEUSupportOptions : Instantiate GetEUSupportOptions
func (*CaseManagementV1) NewGetEUSupportOptions() *GetEUSupportOptions {
	return &GetEUSupportOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetEUSupportOptions) SetHeaders(param map[string]string) *GetEUSupportOptions {
	options.Headers = param
	return options
}

// GetResolutionCodesOptions : The GetResolutionCodes options.
type GetResolutionCodesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetResolutionCodesOptions : Instantiate GetResolutionCodesOptions
func (*CaseManagementV1) NewGetResolutionCodesOptions() *GetResolutionCodesOptions {
	return &GetResolutionCodesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetResolutionCodesOptions) SetHeaders(param map[string]string) *GetResolutionCodesOptions {
	options.Headers = param
	return options
}

// GetStatusesOptions : The GetStatuses options.
type GetStatusesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStatusesOptions : Instantiate GetStatusesOptions
func (*CaseManagementV1) NewGetStatusesOptions() *GetStatusesOptions {
	return &GetStatusesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetStatusesOptions) SetHeaders(param map[string]string) *GetStatusesOptions {
	options.Headers = param
	return options
}

// GetTechnicalOfferingsOptions : The GetTechnicalOfferings options.
type GetTechnicalOfferingsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTechnicalOfferingsOptions : Instantiate GetTechnicalOfferingsOptions
func (*CaseManagementV1) NewGetTechnicalOfferingsOptions() *GetTechnicalOfferingsOptions {
	return &GetTechnicalOfferingsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetTechnicalOfferingsOptions) SetHeaders(param map[string]string) *GetTechnicalOfferingsOptions {
	options.Headers = param
	return options
}

// OfferingItemType : the offering type.
type OfferingItemType struct {
	// the offering type's group.
	Group *string `json:"group,omitempty"`

	// the offering type's key value.
	Key *string `json:"key,omitempty"`
}

// Constants associated with the OfferingItemType.Group property.
// the offering type's group.
const (
	OfferingItemType_Group_Category = "category"
	OfferingItemType_Group_CrnServiceName = "crn_service_name"
)


// UnmarshalOfferingItemType constructs an instance of OfferingItemType from the specified map.
func UnmarshalOfferingItemType(m map[string]interface{}) (result *OfferingItemType, err error) {
	obj := new(OfferingItemType)
	obj.Group, err = core.UnmarshalString(m, "group")
	if err != nil {
		return
	}
	obj.Key, err = core.UnmarshalString(m, "key")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOfferingItemTypeSlice unmarshals a slice of OfferingItemType instances from the specified list of maps.
func UnmarshalOfferingItemTypeSlice(s []interface{}) (slice []OfferingItemType, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OfferingItemType'")
			return
		}
		obj, e := UnmarshalOfferingItemType(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOfferingItemTypeAsProperty unmarshals an instance of OfferingItemType that is stored as a property
// within the specified map.
func UnmarshalOfferingItemTypeAsProperty(m map[string]interface{}, propertyName string) (result *OfferingItemType, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OfferingItemType'", propertyName)
			return
		}
		result, err = UnmarshalOfferingItemType(objMap)
	}
	return
}

// UnmarshalOfferingItemTypeSliceAsProperty unmarshals a slice of OfferingItemType instances that are stored as a property
// within the specified map.
func UnmarshalOfferingItemTypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OfferingItemType, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OfferingItemType'", propertyName)
			return
		}
		slice, err = UnmarshalOfferingItemTypeSlice(vSlice)
	}
	return
}

// OfferingPayloadType : Resource offering type.
type OfferingPayloadType struct {
	// the offering type's group.
	Group *string `json:"group,omitempty"`

	// the offering type's key.
	Key *string `json:"key,omitempty"`

	// the offering type's identifier.
	ID *string `json:"id,omitempty"`

	// the offering type's kind.
	Kind *string `json:"kind,omitempty"`
}

// Constants associated with the OfferingPayloadType.Group property.
// the offering type's group.
const (
	OfferingPayloadType_Group_Category = "category"
	OfferingPayloadType_Group_CrnServiceName = "crn_service_name"
)


// UnmarshalOfferingPayloadType constructs an instance of OfferingPayloadType from the specified map.
func UnmarshalOfferingPayloadType(m map[string]interface{}) (result *OfferingPayloadType, err error) {
	obj := new(OfferingPayloadType)
	obj.Group, err = core.UnmarshalString(m, "group")
	if err != nil {
		return
	}
	obj.Key, err = core.UnmarshalString(m, "key")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Kind, err = core.UnmarshalString(m, "kind")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOfferingPayloadTypeSlice unmarshals a slice of OfferingPayloadType instances from the specified list of maps.
func UnmarshalOfferingPayloadTypeSlice(s []interface{}) (slice []OfferingPayloadType, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OfferingPayloadType'")
			return
		}
		obj, e := UnmarshalOfferingPayloadType(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOfferingPayloadTypeAsProperty unmarshals an instance of OfferingPayloadType that is stored as a property
// within the specified map.
func UnmarshalOfferingPayloadTypeAsProperty(m map[string]interface{}, propertyName string) (result *OfferingPayloadType, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OfferingPayloadType'", propertyName)
			return
		}
		result, err = UnmarshalOfferingPayloadType(objMap)
	}
	return
}

// UnmarshalOfferingPayloadTypeSliceAsProperty unmarshals a slice of OfferingPayloadType instances that are stored as a property
// within the specified map.
func UnmarshalOfferingPayloadTypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OfferingPayloadType, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OfferingPayloadType'", propertyName)
			return
		}
		slice, err = UnmarshalOfferingPayloadTypeSlice(vSlice)
	}
	return
}

// RemoveWatchlistOptions : The RemoveWatchlist options.
type RemoveWatchlistOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// List of users to be added or removed from the watchlist of a case.
	Watchlist []UserIdAndRealm `json:"watchlist,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveWatchlistOptions : Instantiate RemoveWatchlistOptions
func (*CaseManagementV1) NewRemoveWatchlistOptions(caseNumber string) *RemoveWatchlistOptions {
	return &RemoveWatchlistOptions{
		CaseNumber: core.StringPtr(caseNumber),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *RemoveWatchlistOptions) SetCaseNumber(caseNumber string) *RemoveWatchlistOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetWatchlist : Allow user to set Watchlist
func (options *RemoveWatchlistOptions) SetWatchlist(watchlist []UserIdAndRealm) *RemoveWatchlistOptions {
	options.Watchlist = watchlist
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveWatchlistOptions) SetHeaders(param map[string]string) *RemoveWatchlistOptions {
	options.Headers = param
	return options
}

// UpdateCaseStatusOptions : The UpdateCaseStatus options.
type UpdateCaseStatusOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// the action to perform on the case.
	Action *string `json:"action" validate:"required"`

	// a comment to be associated with the updated status.
	Comment *string `json:"comment,omitempty"`

	// * 1: Client error
	// * 2: Defect found with Component/Service
	// * 3: Documentation Error
	// * 4: Sollution found in forums
	// * 5: Solution found in public Documentation
	// * 6: Solution no longer required
	// * 7: Solution provided by IBM outside of support case
	// * 8: Solution provided by IBM support engineer.
	ResolutionCode *int64 `json:"resolution_code,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateCaseStatusOptions.Action property.
// the action to perform on the case.
const (
	UpdateCaseStatusOptions_Action_Accept = "accept"
	UpdateCaseStatusOptions_Action_Resolve = "resolve"
	UpdateCaseStatusOptions_Action_Unresolve = "unresolve"
)

// NewUpdateCaseStatusOptions : Instantiate UpdateCaseStatusOptions
func (*CaseManagementV1) NewUpdateCaseStatusOptions(caseNumber string, action string) *UpdateCaseStatusOptions {
	return &UpdateCaseStatusOptions{
		CaseNumber: core.StringPtr(caseNumber),
		Action: core.StringPtr(action),
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *UpdateCaseStatusOptions) SetCaseNumber(caseNumber string) *UpdateCaseStatusOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetAction : Allow user to set Action
func (options *UpdateCaseStatusOptions) SetAction(action string) *UpdateCaseStatusOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetComment : Allow user to set Comment
func (options *UpdateCaseStatusOptions) SetComment(comment string) *UpdateCaseStatusOptions {
	options.Comment = core.StringPtr(comment)
	return options
}

// SetResolutionCode : Allow user to set ResolutionCode
func (options *UpdateCaseStatusOptions) SetResolutionCode(resolutionCode int64) *UpdateCaseStatusOptions {
	options.ResolutionCode = core.Int64Ptr(resolutionCode)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateCaseStatusOptions) SetHeaders(param map[string]string) *UpdateCaseStatusOptions {
	options.Headers = param
	return options
}

// UploadFileOptions : The UploadFile options.
type UploadFileOptions struct {
	// Unique identifier of a case.
	CaseNumber *string `json:"case_number" validate:"required"`

	// file of supported types, 8MB in size limit.
	File io.ReadCloser `json:"file" validate:"required"`

	// The content type of file.
	FileContentType *string `json:"file_content_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUploadFileOptions : Instantiate UploadFileOptions
func (*CaseManagementV1) NewUploadFileOptions(caseNumber string, file io.ReadCloser) *UploadFileOptions {
	return &UploadFileOptions{
		CaseNumber: core.StringPtr(caseNumber),
		File: file,
	}
}

// SetCaseNumber : Allow user to set CaseNumber
func (options *UploadFileOptions) SetCaseNumber(caseNumber string) *UploadFileOptions {
	options.CaseNumber = core.StringPtr(caseNumber)
	return options
}

// SetFile : Allow user to set File
func (options *UploadFileOptions) SetFile(file io.ReadCloser) *UploadFileOptions {
	options.File = file
	return options
}

// SetFileContentType : Allow user to set FileContentType
func (options *UploadFileOptions) SetFileContentType(fileContentType string) *UploadFileOptions {
	options.FileContentType = core.StringPtr(fileContentType)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UploadFileOptions) SetHeaders(param map[string]string) *UploadFileOptions {
	options.Headers = param
	return options
}

// AddWatchlistResults : the response returned by the `add_watchlist` operation.
type AddWatchlistResults struct {
	// List of successfully added user IDs.
	Added []User `json:"added,omitempty"`

	// List of failed-to-add user IDs.
	Failed []User `json:"failed,omitempty"`
}


// UnmarshalAddWatchlistResults constructs an instance of AddWatchlistResults from the specified map.
func UnmarshalAddWatchlistResults(m map[string]interface{}) (result *AddWatchlistResults, err error) {
	obj := new(AddWatchlistResults)
	obj.Added, err = UnmarshalUserSliceAsProperty(m, "added")
	if err != nil {
		return
	}
	obj.Failed, err = UnmarshalUserSliceAsProperty(m, "failed")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAddWatchlistResultsSlice unmarshals a slice of AddWatchlistResults instances from the specified list of maps.
func UnmarshalAddWatchlistResultsSlice(s []interface{}) (slice []AddWatchlistResults, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'AddWatchlistResults'")
			return
		}
		obj, e := UnmarshalAddWatchlistResults(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAddWatchlistResultsAsProperty unmarshals an instance of AddWatchlistResults that is stored as a property
// within the specified map.
func UnmarshalAddWatchlistResultsAsProperty(m map[string]interface{}, propertyName string) (result *AddWatchlistResults, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'AddWatchlistResults'", propertyName)
			return
		}
		result, err = UnmarshalAddWatchlistResults(objMap)
	}
	return
}

// UnmarshalAddWatchlistResultsSliceAsProperty unmarshals a slice of AddWatchlistResults instances that are stored as a property
// within the specified map.
func UnmarshalAddWatchlistResultsSliceAsProperty(m map[string]interface{}, propertyName string) (slice []AddWatchlistResults, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'AddWatchlistResults'", propertyName)
			return
		}
		slice, err = UnmarshalAddWatchlistResultsSlice(vSlice)
	}
	return
}

// Attachment : Details of an attachment.
type Attachment struct {
	// Unique identifier of the attachment in database.
	ID *string `json:"id,omitempty"`

	// Name of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Size of the attachment in bytes.
	SizeInBytes *int64 `json:"size_in_bytes,omitempty"`

	// Date time of uploading.
	CreatedAt *string `json:"created_at,omitempty"`

	// URL of the attachment used to download.
	URL *string `json:"url,omitempty"`
}


// UnmarshalAttachment constructs an instance of Attachment from the specified map.
func UnmarshalAttachment(m map[string]interface{}) (result *Attachment, err error) {
	obj := new(Attachment)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Filename, err = core.UnmarshalString(m, "filename")
	if err != nil {
		return
	}
	obj.SizeInBytes, err = core.UnmarshalInt64(m, "size_in_bytes")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalString(m, "created_at")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAttachmentSlice unmarshals a slice of Attachment instances from the specified list of maps.
func UnmarshalAttachmentSlice(s []interface{}) (slice []Attachment, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Attachment'")
			return
		}
		obj, e := UnmarshalAttachment(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAttachmentAsProperty unmarshals an instance of Attachment that is stored as a property
// within the specified map.
func UnmarshalAttachmentAsProperty(m map[string]interface{}, propertyName string) (result *Attachment, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Attachment'", propertyName)
			return
		}
		result, err = UnmarshalAttachment(objMap)
	}
	return
}

// UnmarshalAttachmentSliceAsProperty unmarshals a slice of Attachment instances that are stored as a property
// within the specified map.
func UnmarshalAttachmentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Attachment, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Attachment'", propertyName)
			return
		}
		slice, err = UnmarshalAttachmentSlice(vSlice)
	}
	return
}

// Case : a case object.
type Case struct {
	// Number/ID of the case.
	Number *string `json:"number,omitempty"`

	// A short description of what the case is about.
	ShortEscription *string `json:"short_escription,omitempty"`

	// A full description of what the case is about.
	Description *string `json:"description,omitempty"`

	// Date time of case creation in UTC.
	CreatedAt *string `json:"created_at,omitempty"`

	// Case creator.
	CreatedBy *User `json:"created_by,omitempty"`

	// Date time of the last update on the case in UTC.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Person who makes the most recent update to the case.
	UpdatedBy *User `json:"updated_by,omitempty"`

	// Name of the console to interact with the contact.
	ContactType *string `json:"contact_type,omitempty"`

	// Person who reported the case.
	Contact *User `json:"contact,omitempty"`

	// Status of the case.
	Status *string `json:"status,omitempty"`

	// The severity of the case.
	Severity *float64 `json:"severity,omitempty"`

	// Support tier of the account.
	SupportTier *string `json:"support_tier,omitempty"`

	// Standard reasons of resolving case.
	Resolution *string `json:"resolution,omitempty"`

	// Notes of case closing.
	CloseNotes *string `json:"close_notes,omitempty"`

	// Specifies if the case should be treated as EU regulated.
	Eu *Eu `json:"eu,omitempty"`

	// User IDs in the watchlist.
	Watchlist []User `json:"watchlist,omitempty"`

	// List of attachments/files of the case.
	Attachments []Attachment `json:"attachments,omitempty"`

	// A catalog offering associated with a case.
	Offering *Offering `json:"offering,omitempty"`

	// List of attached resources.
	Resources []Resource `json:"resources,omitempty"`

	// List of comments/updates sorted in chronological order.
	Comments []Comment `json:"comments,omitempty"`
}

// Constants associated with the Case.ContactType property.
// Name of the console to interact with the contact.
const (
	Case_ContactType_CloudSupportCenter = "Cloud Support Center"
	Case_ContactType_ImsConsole = "IMS Console"
)

// Constants associated with the Case.SupportTier property.
// Support tier of the account.
const (
	Case_SupportTier_Basic = "Basic"
	Case_SupportTier_Free = "Free"
	Case_SupportTier_Premium = "Premium"
	Case_SupportTier_Standard = "Standard"
)


// UnmarshalCase constructs an instance of Case from the specified map.
func UnmarshalCase(m map[string]interface{}) (result *Case, err error) {
	obj := new(Case)
	obj.Number, err = core.UnmarshalString(m, "number")
	if err != nil {
		return
	}
	obj.ShortEscription, err = core.UnmarshalString(m, "short_escription")
	if err != nil {
		return
	}
	obj.Description, err = core.UnmarshalString(m, "description")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalString(m, "created_at")
	if err != nil {
		return
	}
	obj.CreatedBy, err = UnmarshalUserAsProperty(m, "created_by")
	if err != nil {
		return
	}
	obj.UpdatedAt, err = core.UnmarshalString(m, "updated_at")
	if err != nil {
		return
	}
	obj.UpdatedBy, err = UnmarshalUserAsProperty(m, "updated_by")
	if err != nil {
		return
	}
	obj.ContactType, err = core.UnmarshalString(m, "contact_type")
	if err != nil {
		return
	}
	obj.Contact, err = UnmarshalUserAsProperty(m, "contact")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Severity, err = core.UnmarshalFloat64(m, "severity")
	if err != nil {
		return
	}
	obj.SupportTier, err = core.UnmarshalString(m, "support_tier")
	if err != nil {
		return
	}
	obj.Resolution, err = core.UnmarshalString(m, "resolution")
	if err != nil {
		return
	}
	obj.CloseNotes, err = core.UnmarshalString(m, "close_notes")
	if err != nil {
		return
	}
	obj.Eu, err = UnmarshalEuAsProperty(m, "eu")
	if err != nil {
		return
	}
	obj.Watchlist, err = UnmarshalUserSliceAsProperty(m, "watchlist")
	if err != nil {
		return
	}
	obj.Attachments, err = UnmarshalAttachmentSliceAsProperty(m, "attachments")
	if err != nil {
		return
	}
	obj.Offering, err = UnmarshalOfferingAsProperty(m, "offering")
	if err != nil {
		return
	}
	obj.Resources, err = UnmarshalResourceSliceAsProperty(m, "resources")
	if err != nil {
		return
	}
	obj.Comments, err = UnmarshalCommentSliceAsProperty(m, "comments")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCaseSlice unmarshals a slice of Case instances from the specified list of maps.
func UnmarshalCaseSlice(s []interface{}) (slice []Case, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Case'")
			return
		}
		obj, e := UnmarshalCase(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCaseAsProperty unmarshals an instance of Case that is stored as a property
// within the specified map.
func UnmarshalCaseAsProperty(m map[string]interface{}, propertyName string) (result *Case, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Case'", propertyName)
			return
		}
		result, err = UnmarshalCase(objMap)
	}
	return
}

// UnmarshalCaseSliceAsProperty unmarshals a slice of Case instances that are stored as a property
// within the specified map.
func UnmarshalCaseSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Case, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Case'", propertyName)
			return
		}
		slice, err = UnmarshalCaseSlice(vSlice)
	}
	return
}

// CaseCollection : a collection of cases returned by the `get_cases` operation.
type CaseCollection struct {
	// Total number of cases satisfying the query.
	TotalCount *int64 `json:"total_count,omitempty"`

	// the first page of the case collection.
	First *PaginationLink `json:"first,omitempty"`

	// the next page of the case collection.
	Next *PaginationLink `json:"next,omitempty"`

	// the previous page of the case collection.
	Previous *PaginationLink `json:"previous,omitempty"`

	// the last page of the case collection.
	Last *PaginationLink `json:"last,omitempty"`

	// the cases returned in the collection.
	Cases []Case `json:"cases,omitempty"`
}


// UnmarshalCaseCollection constructs an instance of CaseCollection from the specified map.
func UnmarshalCaseCollection(m map[string]interface{}) (result *CaseCollection, err error) {
	obj := new(CaseCollection)
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	obj.First, err = UnmarshalPaginationLinkAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalPaginationLinkAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.Previous, err = UnmarshalPaginationLinkAsProperty(m, "previous")
	if err != nil {
		return
	}
	obj.Last, err = UnmarshalPaginationLinkAsProperty(m, "last")
	if err != nil {
		return
	}
	obj.Cases, err = UnmarshalCaseSliceAsProperty(m, "cases")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCaseCollectionSlice unmarshals a slice of CaseCollection instances from the specified list of maps.
func UnmarshalCaseCollectionSlice(s []interface{}) (slice []CaseCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CaseCollection'")
			return
		}
		obj, e := UnmarshalCaseCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCaseCollectionAsProperty unmarshals an instance of CaseCollection that is stored as a property
// within the specified map.
func UnmarshalCaseCollectionAsProperty(m map[string]interface{}, propertyName string) (result *CaseCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CaseCollection'", propertyName)
			return
		}
		result, err = UnmarshalCaseCollection(objMap)
	}
	return
}

// UnmarshalCaseCollectionSliceAsProperty unmarshals a slice of CaseCollection instances that are stored as a property
// within the specified map.
func UnmarshalCaseCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CaseCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CaseCollection'", propertyName)
			return
		}
		slice, err = UnmarshalCaseCollectionSlice(vSlice)
	}
	return
}

// Comment : A comment or update associated with a case.
type Comment struct {
	// The comment.
	Value *string `json:"value,omitempty"`

	// Timestamp of when comment is added.
	AddedAt *string `json:"added_at,omitempty"`

	// The person who added the comment.
	AddedBy *User `json:"added_by,omitempty"`
}


// UnmarshalComment constructs an instance of Comment from the specified map.
func UnmarshalComment(m map[string]interface{}) (result *Comment, err error) {
	obj := new(Comment)
	obj.Value, err = core.UnmarshalString(m, "value")
	if err != nil {
		return
	}
	obj.AddedAt, err = core.UnmarshalString(m, "added_at")
	if err != nil {
		return
	}
	obj.AddedBy, err = UnmarshalUserAsProperty(m, "added_by")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCommentSlice unmarshals a slice of Comment instances from the specified list of maps.
func UnmarshalCommentSlice(s []interface{}) (slice []Comment, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Comment'")
			return
		}
		obj, e := UnmarshalComment(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCommentAsProperty unmarshals an instance of Comment that is stored as a property
// within the specified map.
func UnmarshalCommentAsProperty(m map[string]interface{}, propertyName string) (result *Comment, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Comment'", propertyName)
			return
		}
		result, err = UnmarshalComment(objMap)
	}
	return
}

// UnmarshalCommentSliceAsProperty unmarshals a slice of Comment instances that are stored as a property
// within the specified map.
func UnmarshalCommentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Comment, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Comment'", propertyName)
			return
		}
		slice, err = UnmarshalCommentSlice(vSlice)
	}
	return
}

// DeleteFileResponse : The response returned by the `delete_file` operation.
type DeleteFileResponse struct {
	// List of attachments/files of the case.
	Attachments []Attachment `json:"attachments,omitempty"`
}


// UnmarshalDeleteFileResponse constructs an instance of DeleteFileResponse from the specified map.
func UnmarshalDeleteFileResponse(m map[string]interface{}) (result *DeleteFileResponse, err error) {
	obj := new(DeleteFileResponse)
	obj.Attachments, err = UnmarshalAttachmentSliceAsProperty(m, "attachments")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalDeleteFileResponseSlice unmarshals a slice of DeleteFileResponse instances from the specified list of maps.
func UnmarshalDeleteFileResponseSlice(s []interface{}) (slice []DeleteFileResponse, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'DeleteFileResponse'")
			return
		}
		obj, e := UnmarshalDeleteFileResponse(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalDeleteFileResponseAsProperty unmarshals an instance of DeleteFileResponse that is stored as a property
// within the specified map.
func UnmarshalDeleteFileResponseAsProperty(m map[string]interface{}, propertyName string) (result *DeleteFileResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'DeleteFileResponse'", propertyName)
			return
		}
		result, err = UnmarshalDeleteFileResponse(objMap)
	}
	return
}

// UnmarshalDeleteFileResponseSliceAsProperty unmarshals a slice of DeleteFileResponse instances that are stored as a property
// within the specified map.
func UnmarshalDeleteFileResponseSliceAsProperty(m map[string]interface{}, propertyName string) (slice []DeleteFileResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'DeleteFileResponse'", propertyName)
			return
		}
		slice, err = UnmarshalDeleteFileResponseSlice(vSlice)
	}
	return
}

// Eu : Specifies if the case should be treated as EU regulated.
type Eu struct {
	// Identifying whether the case has EU Support.
	Support *bool `json:"support,omitempty"`

	// Information about the data center.
	DataCenter *string `json:"data_center,omitempty"`
}


// UnmarshalEu constructs an instance of Eu from the specified map.
func UnmarshalEu(m map[string]interface{}) (result *Eu, err error) {
	obj := new(Eu)
	obj.Support, err = core.UnmarshalBool(m, "support")
	if err != nil {
		return
	}
	obj.DataCenter, err = core.UnmarshalString(m, "data_center")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalEuSlice unmarshals a slice of Eu instances from the specified list of maps.
func UnmarshalEuSlice(s []interface{}) (slice []Eu, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Eu'")
			return
		}
		obj, e := UnmarshalEu(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalEuAsProperty unmarshals an instance of Eu that is stored as a property
// within the specified map.
func UnmarshalEuAsProperty(m map[string]interface{}, propertyName string) (result *Eu, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Eu'", propertyName)
			return
		}
		result, err = UnmarshalEu(objMap)
	}
	return
}

// UnmarshalEuSliceAsProperty unmarshals a slice of Eu instances that are stored as a property
// within the specified map.
func UnmarshalEuSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Eu, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Eu'", propertyName)
			return
		}
		slice, err = UnmarshalEuSlice(vSlice)
	}
	return
}

// EuPayload : Specify if the case should be treated as EU regulated. Only one of the following properties is required. Call EU
// support utility endpoint to determine which property must be specified for your account.
type EuPayload struct {
	// indicates whether the case should be treated as EU regulated.
	Supported *bool `json:"supported,omitempty"`

	// If EU supported utility endpoint specifies datacenter then pass the datacenter id to mark a case as EU supported.
	DataCenter *int64 `json:"data_center,omitempty"`
}


// UnmarshalEuPayload constructs an instance of EuPayload from the specified map.
func UnmarshalEuPayload(m map[string]interface{}) (result *EuPayload, err error) {
	obj := new(EuPayload)
	obj.Supported, err = core.UnmarshalBool(m, "supported")
	if err != nil {
		return
	}
	obj.DataCenter, err = core.UnmarshalInt64(m, "data_center")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalEuPayloadSlice unmarshals a slice of EuPayload instances from the specified list of maps.
func UnmarshalEuPayloadSlice(s []interface{}) (slice []EuPayload, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'EuPayload'")
			return
		}
		obj, e := UnmarshalEuPayload(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalEuPayloadAsProperty unmarshals an instance of EuPayload that is stored as a property
// within the specified map.
func UnmarshalEuPayloadAsProperty(m map[string]interface{}, propertyName string) (result *EuPayload, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'EuPayload'", propertyName)
			return
		}
		result, err = UnmarshalEuPayload(objMap)
	}
	return
}

// UnmarshalEuPayloadSliceAsProperty unmarshals a slice of EuPayload instances that are stored as a property
// within the specified map.
func UnmarshalEuPayloadSliceAsProperty(m map[string]interface{}, propertyName string) (slice []EuPayload, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'EuPayload'", propertyName)
			return
		}
		slice, err = UnmarshalEuPayloadSlice(vSlice)
	}
	return
}

// EuSupport : information needed to treat a case as EU regulated.
type EuSupport struct {
	// Property which must be specified on eu property of case creation payload.
	Property *string `json:"property,omitempty"`

	// If the value of property is 'datacenter' then select datacenter by passing its id in `eu.datacenter` field of case
	// creation payload.
	Values []interface{} `json:"values,omitempty"`
}

// Constants associated with the EuSupport.Property property.
// Property which must be specified on eu property of case creation payload.
const (
	EuSupport_Property_DataCenter = "data_center"
	EuSupport_Property_Supported = "supported"
)


// UnmarshalEuSupport constructs an instance of EuSupport from the specified map.
func UnmarshalEuSupport(m map[string]interface{}) (result *EuSupport, err error) {
	obj := new(EuSupport)
	obj.Property, err = core.UnmarshalString(m, "property")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalAnySlice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalEuSupportSlice unmarshals a slice of EuSupport instances from the specified list of maps.
func UnmarshalEuSupportSlice(s []interface{}) (slice []EuSupport, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'EuSupport'")
			return
		}
		obj, e := UnmarshalEuSupport(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalEuSupportAsProperty unmarshals an instance of EuSupport that is stored as a property
// within the specified map.
func UnmarshalEuSupportAsProperty(m map[string]interface{}, propertyName string) (result *EuSupport, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'EuSupport'", propertyName)
			return
		}
		result, err = UnmarshalEuSupport(objMap)
	}
	return
}

// UnmarshalEuSupportSliceAsProperty unmarshals a slice of EuSupport instances that are stored as a property
// within the specified map.
func UnmarshalEuSupportSliceAsProperty(m map[string]interface{}, propertyName string) (slice []EuSupport, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'EuSupport'", propertyName)
			return
		}
		slice, err = UnmarshalEuSupportSlice(vSlice)
	}
	return
}

// Offering : A catalog offering associated with a case.
type Offering struct {
	// id of the catalog offering.
	ID *string `json:"id,omitempty"`

	// display name of the catalog offering.
	Value *string `json:"value,omitempty"`
}


// UnmarshalOffering constructs an instance of Offering from the specified map.
func UnmarshalOffering(m map[string]interface{}) (result *Offering, err error) {
	obj := new(Offering)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalString(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOfferingSlice unmarshals a slice of Offering instances from the specified list of maps.
func UnmarshalOfferingSlice(s []interface{}) (slice []Offering, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Offering'")
			return
		}
		obj, e := UnmarshalOffering(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOfferingAsProperty unmarshals an instance of Offering that is stored as a property
// within the specified map.
func UnmarshalOfferingAsProperty(m map[string]interface{}, propertyName string) (result *Offering, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Offering'", propertyName)
			return
		}
		result, err = UnmarshalOffering(objMap)
	}
	return
}

// UnmarshalOfferingSliceAsProperty unmarshals a slice of Offering instances that are stored as a property
// within the specified map.
func UnmarshalOfferingSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Offering, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Offering'", propertyName)
			return
		}
		slice, err = UnmarshalOfferingSlice(vSlice)
	}
	return
}

// OfferingItem : an individual offering.
type OfferingItem struct {
	// the name of the offering.
	Name *string `json:"name,omitempty"`

	// the offering type.
	Type *OfferingItemType `json:"type,omitempty"`
}


// UnmarshalOfferingItem constructs an instance of OfferingItem from the specified map.
func UnmarshalOfferingItem(m map[string]interface{}) (result *OfferingItem, err error) {
	obj := new(OfferingItem)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Type, err = UnmarshalOfferingItemTypeAsProperty(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOfferingItemSlice unmarshals a slice of OfferingItem instances from the specified list of maps.
func UnmarshalOfferingItemSlice(s []interface{}) (slice []OfferingItem, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OfferingItem'")
			return
		}
		obj, e := UnmarshalOfferingItem(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOfferingItemAsProperty unmarshals an instance of OfferingItem that is stored as a property
// within the specified map.
func UnmarshalOfferingItemAsProperty(m map[string]interface{}, propertyName string) (result *OfferingItem, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OfferingItem'", propertyName)
			return
		}
		result, err = UnmarshalOfferingItem(objMap)
	}
	return
}

// UnmarshalOfferingItemSliceAsProperty unmarshals a slice of OfferingItem instances that are stored as a property
// within the specified map.
func UnmarshalOfferingItemSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OfferingItem, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OfferingItem'", propertyName)
			return
		}
		slice, err = UnmarshalOfferingItemSlice(vSlice)
	}
	return
}

// OfferingPayload : The offering of a case to be created.
type OfferingPayload struct {
	// Resource offering name.
	Name *string `json:"name" validate:"required"`

	// Resource offering type.
	Type *OfferingPayloadType `json:"type" validate:"required"`
}


// NewOfferingPayload : Instantiate OfferingPayload (Generic Model Constructor)
func (*CaseManagementV1) NewOfferingPayload(name string, typeVar *OfferingPayloadType) (model *OfferingPayload, err error) {
	model = &OfferingPayload{
		Name: core.StringPtr(name),
		Type: typeVar,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalOfferingPayload constructs an instance of OfferingPayload from the specified map.
func UnmarshalOfferingPayload(m map[string]interface{}) (result *OfferingPayload, err error) {
	obj := new(OfferingPayload)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Type, err = UnmarshalOfferingPayloadTypeAsProperty(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOfferingPayloadSlice unmarshals a slice of OfferingPayload instances from the specified list of maps.
func UnmarshalOfferingPayloadSlice(s []interface{}) (slice []OfferingPayload, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OfferingPayload'")
			return
		}
		obj, e := UnmarshalOfferingPayload(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOfferingPayloadAsProperty unmarshals an instance of OfferingPayload that is stored as a property
// within the specified map.
func UnmarshalOfferingPayloadAsProperty(m map[string]interface{}, propertyName string) (result *OfferingPayload, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OfferingPayload'", propertyName)
			return
		}
		result, err = UnmarshalOfferingPayload(objMap)
	}
	return
}

// UnmarshalOfferingPayloadSliceAsProperty unmarshals a slice of OfferingPayload instances that are stored as a property
// within the specified map.
func UnmarshalOfferingPayloadSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OfferingPayload, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OfferingPayload'", propertyName)
			return
		}
		slice, err = UnmarshalOfferingPayloadSlice(vSlice)
	}
	return
}

// PaginationLink : a reference to a page of results within a case collection.
type PaginationLink struct {
	// the page reference as a URI.
	Href *string `json:"href,omitempty"`
}


// UnmarshalPaginationLink constructs an instance of PaginationLink from the specified map.
func UnmarshalPaginationLink(m map[string]interface{}) (result *PaginationLink, err error) {
	obj := new(PaginationLink)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPaginationLinkSlice unmarshals a slice of PaginationLink instances from the specified list of maps.
func UnmarshalPaginationLinkSlice(s []interface{}) (slice []PaginationLink, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PaginationLink'")
			return
		}
		obj, e := UnmarshalPaginationLink(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPaginationLinkAsProperty unmarshals an instance of PaginationLink that is stored as a property
// within the specified map.
func UnmarshalPaginationLinkAsProperty(m map[string]interface{}, propertyName string) (result *PaginationLink, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PaginationLink'", propertyName)
			return
		}
		result, err = UnmarshalPaginationLink(objMap)
	}
	return
}

// UnmarshalPaginationLinkSliceAsProperty unmarshals a slice of PaginationLink instances that are stored as a property
// within the specified map.
func UnmarshalPaginationLinkSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PaginationLink, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PaginationLink'", propertyName)
			return
		}
		slice, err = UnmarshalPaginationLinkSlice(vSlice)
	}
	return
}

// ResolutionCode : a resolution code.
type ResolutionCode struct {
	// the resolution code identifier.
	ID *float64 `json:"id,omitempty"`

	// the resolution code value.
	Value *string `json:"value,omitempty"`
}


// UnmarshalResolutionCode constructs an instance of ResolutionCode from the specified map.
func UnmarshalResolutionCode(m map[string]interface{}) (result *ResolutionCode, err error) {
	obj := new(ResolutionCode)
	obj.ID, err = core.UnmarshalFloat64(m, "id")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalString(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalResolutionCodeSlice unmarshals a slice of ResolutionCode instances from the specified list of maps.
func UnmarshalResolutionCodeSlice(s []interface{}) (slice []ResolutionCode, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ResolutionCode'")
			return
		}
		obj, e := UnmarshalResolutionCode(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalResolutionCodeAsProperty unmarshals an instance of ResolutionCode that is stored as a property
// within the specified map.
func UnmarshalResolutionCodeAsProperty(m map[string]interface{}, propertyName string) (result *ResolutionCode, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ResolutionCode'", propertyName)
			return
		}
		result, err = UnmarshalResolutionCode(objMap)
	}
	return
}

// UnmarshalResolutionCodeSliceAsProperty unmarshals a slice of ResolutionCode instances that are stored as a property
// within the specified map.
func UnmarshalResolutionCodeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ResolutionCode, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ResolutionCode'", propertyName)
			return
		}
		slice, err = UnmarshalResolutionCodeSlice(vSlice)
	}
	return
}

// ResolutionCodesResponse : the resolution codes returned by the `get_resolution_codes` operation.
type ResolutionCodesResponse struct {
	// the set of supported resolution codes.
	ResolutionCodes []ResolutionCode `json:"resolution_codes,omitempty"`
}


// UnmarshalResolutionCodesResponse constructs an instance of ResolutionCodesResponse from the specified map.
func UnmarshalResolutionCodesResponse(m map[string]interface{}) (result *ResolutionCodesResponse, err error) {
	obj := new(ResolutionCodesResponse)
	obj.ResolutionCodes, err = UnmarshalResolutionCodeSliceAsProperty(m, "resolution_codes")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalResolutionCodesResponseSlice unmarshals a slice of ResolutionCodesResponse instances from the specified list of maps.
func UnmarshalResolutionCodesResponseSlice(s []interface{}) (slice []ResolutionCodesResponse, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ResolutionCodesResponse'")
			return
		}
		obj, e := UnmarshalResolutionCodesResponse(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalResolutionCodesResponseAsProperty unmarshals an instance of ResolutionCodesResponse that is stored as a property
// within the specified map.
func UnmarshalResolutionCodesResponseAsProperty(m map[string]interface{}, propertyName string) (result *ResolutionCodesResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ResolutionCodesResponse'", propertyName)
			return
		}
		result, err = UnmarshalResolutionCodesResponse(objMap)
	}
	return
}

// UnmarshalResolutionCodesResponseSliceAsProperty unmarshals a slice of ResolutionCodesResponse instances that are stored as a property
// within the specified map.
func UnmarshalResolutionCodesResponseSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ResolutionCodesResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ResolutionCodesResponse'", propertyName)
			return
		}
		slice, err = UnmarshalResolutionCodesResponseSlice(vSlice)
	}
	return
}

// Resource : a resource associated with a case.
type Resource struct {
	// Cloud Resource Name of the resource.
	Crn *string `json:"crn,omitempty"`

	// Name of the resource.
	Name *string `json:"name,omitempty"`

	// Only used to attach Classic IaaS devices which have no CRN.
	Type *string `json:"type,omitempty"`

	// Only used to attach Classic IaaS devices which have no CRN. Id of Classic IaaS device.
	ID *int64 `json:"id,omitempty"`

	// A note about this resource.
	Note *string `json:"note,omitempty"`
}


// UnmarshalResource constructs an instance of Resource from the specified map.
func UnmarshalResource(m map[string]interface{}) (result *Resource, err error) {
	obj := new(Resource)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalInt64(m, "id")
	if err != nil {
		return
	}
	obj.Note, err = core.UnmarshalString(m, "note")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalResourceSlice unmarshals a slice of Resource instances from the specified list of maps.
func UnmarshalResourceSlice(s []interface{}) (slice []Resource, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Resource'")
			return
		}
		obj, e := UnmarshalResource(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalResourceAsProperty unmarshals an instance of Resource that is stored as a property
// within the specified map.
func UnmarshalResourceAsProperty(m map[string]interface{}, propertyName string) (result *Resource, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Resource'", propertyName)
			return
		}
		result, err = UnmarshalResource(objMap)
	}
	return
}

// UnmarshalResourceSliceAsProperty unmarshals a slice of Resource instances that are stored as a property
// within the specified map.
func UnmarshalResourceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Resource, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Resource'", propertyName)
			return
		}
		slice, err = UnmarshalResourceSlice(vSlice)
	}
	return
}

// Status : A status value used in case filtering.
type Status struct {
	// the status identifier.
	ID *string `json:"id,omitempty"`

	// the status description.
	Description *string `json:"description,omitempty"`
}


// UnmarshalStatus constructs an instance of Status from the specified map.
func UnmarshalStatus(m map[string]interface{}) (result *Status, err error) {
	obj := new(Status)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Description, err = core.UnmarshalString(m, "description")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalStatusSlice unmarshals a slice of Status instances from the specified list of maps.
func UnmarshalStatusSlice(s []interface{}) (slice []Status, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Status'")
			return
		}
		obj, e := UnmarshalStatus(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalStatusAsProperty unmarshals an instance of Status that is stored as a property
// within the specified map.
func UnmarshalStatusAsProperty(m map[string]interface{}, propertyName string) (result *Status, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Status'", propertyName)
			return
		}
		result, err = UnmarshalStatus(objMap)
	}
	return
}

// UnmarshalStatusSliceAsProperty unmarshals a slice of Status instances that are stored as a property
// within the specified map.
func UnmarshalStatusSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Status, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Status'", propertyName)
			return
		}
		slice, err = UnmarshalStatusSlice(vSlice)
	}
	return
}

// StatusesResponse : a collection of status values used in case filtering.
type StatusesResponse struct {
	// the list of status values used incase filtering.
	Statuses []Status `json:"statuses,omitempty"`
}


// UnmarshalStatusesResponse constructs an instance of StatusesResponse from the specified map.
func UnmarshalStatusesResponse(m map[string]interface{}) (result *StatusesResponse, err error) {
	obj := new(StatusesResponse)
	obj.Statuses, err = UnmarshalStatusSliceAsProperty(m, "statuses")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalStatusesResponseSlice unmarshals a slice of StatusesResponse instances from the specified list of maps.
func UnmarshalStatusesResponseSlice(s []interface{}) (slice []StatusesResponse, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'StatusesResponse'")
			return
		}
		obj, e := UnmarshalStatusesResponse(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalStatusesResponseAsProperty unmarshals an instance of StatusesResponse that is stored as a property
// within the specified map.
func UnmarshalStatusesResponseAsProperty(m map[string]interface{}, propertyName string) (result *StatusesResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'StatusesResponse'", propertyName)
			return
		}
		result, err = UnmarshalStatusesResponse(objMap)
	}
	return
}

// UnmarshalStatusesResponseSliceAsProperty unmarshals a slice of StatusesResponse instances that are stored as a property
// within the specified map.
func UnmarshalStatusesResponseSliceAsProperty(m map[string]interface{}, propertyName string) (slice []StatusesResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'StatusesResponse'", propertyName)
			return
		}
		slice, err = UnmarshalStatusesResponseSlice(vSlice)
	}
	return
}

// TechnicalOfferingsResponse : the response for the `get_technical_offerings` operation.
type TechnicalOfferingsResponse struct {
	// a list of offerings.
	Offerings []OfferingItem `json:"offerings,omitempty"`
}


// UnmarshalTechnicalOfferingsResponse constructs an instance of TechnicalOfferingsResponse from the specified map.
func UnmarshalTechnicalOfferingsResponse(m map[string]interface{}) (result *TechnicalOfferingsResponse, err error) {
	obj := new(TechnicalOfferingsResponse)
	obj.Offerings, err = UnmarshalOfferingItemSliceAsProperty(m, "offerings")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalTechnicalOfferingsResponseSlice unmarshals a slice of TechnicalOfferingsResponse instances from the specified list of maps.
func UnmarshalTechnicalOfferingsResponseSlice(s []interface{}) (slice []TechnicalOfferingsResponse, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'TechnicalOfferingsResponse'")
			return
		}
		obj, e := UnmarshalTechnicalOfferingsResponse(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalTechnicalOfferingsResponseAsProperty unmarshals an instance of TechnicalOfferingsResponse that is stored as a property
// within the specified map.
func UnmarshalTechnicalOfferingsResponseAsProperty(m map[string]interface{}, propertyName string) (result *TechnicalOfferingsResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'TechnicalOfferingsResponse'", propertyName)
			return
		}
		result, err = UnmarshalTechnicalOfferingsResponse(objMap)
	}
	return
}

// UnmarshalTechnicalOfferingsResponseSliceAsProperty unmarshals a slice of TechnicalOfferingsResponse instances that are stored as a property
// within the specified map.
func UnmarshalTechnicalOfferingsResponseSliceAsProperty(m map[string]interface{}, propertyName string) (slice []TechnicalOfferingsResponse, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'TechnicalOfferingsResponse'", propertyName)
			return
		}
		slice, err = UnmarshalTechnicalOfferingsResponseSlice(vSlice)
	}
	return
}

// User : information related to a user.
type User struct {
	// Full name of the user.
	Name *string `json:"name,omitempty"`

	// the ID realm.
	Realm *string `json:"realm,omitempty"`

	// unique user ID in the realm specified by the type.
	UserID *string `json:"user_id,omitempty"`
}

// Constants associated with the User.Realm property.
// the ID realm.
const (
	User_Realm_Bss = "BSS"
	User_Realm_Ibmid = "IBMid"
	User_Realm_Sl = "SL"
)


// UnmarshalUser constructs an instance of User from the specified map.
func UnmarshalUser(m map[string]interface{}) (result *User, err error) {
	obj := new(User)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Realm, err = core.UnmarshalString(m, "realm")
	if err != nil {
		return
	}
	obj.UserID, err = core.UnmarshalString(m, "user_id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalUserSlice unmarshals a slice of User instances from the specified list of maps.
func UnmarshalUserSlice(s []interface{}) (slice []User, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'User'")
			return
		}
		obj, e := UnmarshalUser(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalUserAsProperty unmarshals an instance of User that is stored as a property
// within the specified map.
func UnmarshalUserAsProperty(m map[string]interface{}, propertyName string) (result *User, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'User'", propertyName)
			return
		}
		result, err = UnmarshalUser(objMap)
	}
	return
}

// UnmarshalUserSliceAsProperty unmarshals a slice of User instances that are stored as a property
// within the specified map.
func UnmarshalUserSliceAsProperty(m map[string]interface{}, propertyName string) (slice []User, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'User'", propertyName)
			return
		}
		slice, err = UnmarshalUserSlice(vSlice)
	}
	return
}

// UserIdAndRealm : information related to a user.
type UserIdAndRealm struct {
	// the ID realm.
	Realm *string `json:"realm" validate:"required"`

	// unique user ID in the realm specified by the type.
	UserID *string `json:"user_id" validate:"required"`
}

// Constants associated with the UserIdAndRealm.Realm property.
// the ID realm.
const (
	UserIdAndRealm_Realm_Bss = "BSS"
	UserIdAndRealm_Realm_Ibmid = "IBMid"
	UserIdAndRealm_Realm_Sl = "SL"
)


// NewUserIdAndRealm : Instantiate UserIdAndRealm (Generic Model Constructor)
func (*CaseManagementV1) NewUserIdAndRealm(realm string, userID string) (model *UserIdAndRealm, err error) {
	model = &UserIdAndRealm{
		Realm: core.StringPtr(realm),
		UserID: core.StringPtr(userID),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalUserIdAndRealm constructs an instance of UserIdAndRealm from the specified map.
func UnmarshalUserIdAndRealm(m map[string]interface{}) (result *UserIdAndRealm, err error) {
	obj := new(UserIdAndRealm)
	obj.Realm, err = core.UnmarshalString(m, "realm")
	if err != nil {
		return
	}
	obj.UserID, err = core.UnmarshalString(m, "user_id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalUserIdAndRealmSlice unmarshals a slice of UserIdAndRealm instances from the specified list of maps.
func UnmarshalUserIdAndRealmSlice(s []interface{}) (slice []UserIdAndRealm, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'UserIdAndRealm'")
			return
		}
		obj, e := UnmarshalUserIdAndRealm(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalUserIdAndRealmAsProperty unmarshals an instance of UserIdAndRealm that is stored as a property
// within the specified map.
func UnmarshalUserIdAndRealmAsProperty(m map[string]interface{}, propertyName string) (result *UserIdAndRealm, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'UserIdAndRealm'", propertyName)
			return
		}
		result, err = UnmarshalUserIdAndRealm(objMap)
	}
	return
}

// UnmarshalUserIdAndRealmSliceAsProperty unmarshals a slice of UserIdAndRealm instances that are stored as a property
// within the specified map.
func UnmarshalUserIdAndRealmSliceAsProperty(m map[string]interface{}, propertyName string) (slice []UserIdAndRealm, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'UserIdAndRealm'", propertyName)
			return
		}
		slice, err = UnmarshalUserIdAndRealmSlice(vSlice)
	}
	return
}
